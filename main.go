package main

import (
	"fmt"
	docopt "github.com/docopt/docopt-go"
	"github.com/petemoore/pulse-go/pulse"
	"github.com/streadway/amqp"
)

var (
	version = "pulse-go 1.0"
	usage   = `
pulse-go
pulse-go is a very simple command line utility that allows you to specify a list of Pulse
exchanges/routing keys that you wish to bind to, and prints the body of the Pulse messages
to standard out.

  Usage:
      pulse-go -u <pulse_user> -p <pulse_password> (<exchange> <routing_key>)...
      pulse-go -h | --help

  Options:
    -h, --help            Display this help text.
    -u <pulse_user>       The pulse user to connect with (see http://pulse.mozilla.org/).
    -p <pulse_password>   The password to use for connecting to pulse.

  Examples:
    pulse-go -u pmoore_test1 -p potato123 \
        exchange/build/ '#' \
        exchange/taskcluster-queue/v1/task-defined '*.*.*.*.*.null-provisioner.buildbot-try.#'

    This would display all messages from exchange exchange/build/ and only messages from
    exchange/taskcluster-queue/v1/task-defined with provisionerId = "null-provisioner" and
    workerType = "buildbot-try" (see http://docs.taskcluster.net/queue/exchanges/#taskDefined
    for more information).

    Remember to quote your routing key strings on the command line, so they are not
    interpreted by your shell!

    Please note if you are interacting with taskcluster exchanges, please consider using one
    of the following libraries, for better handling:

      * http://github.com/petemoore/taskcluster-client-go
      * https://github.com/taskcluster/taskcluster-client

`
)

func main() {
	// Parse the docopt string and exit on any error or help message.
	arguments, err := docopt.Parse(usage, nil, true, version, false, true)
	if err != nil {
		panic(err)
	}

	pulseUser := arguments["-u"].(string)
	pulsePassword := arguments["-p"].(string)
	exchanges := arguments["<exchange>"].([]string)
	routingKeys := arguments["<routing_key>"].([]string)

	bindings := make([]pulse.Binding, len(exchanges))
	for i := range exchanges {
		bindings[i] = pulse.Bind(routingKeys[i], exchanges[i])
	}

	// Requires that you set your pulse username and pulse password via these
	// environment variables...
	p1 := pulse.NewConnection(pulseUser, pulsePassword)
	// If not connecting to production, you can specify a different url...
	// p1.SetURL("amqp://guest:guest@localhost:5672/")

	// Simple example callback function to just print message body...
	printMe := func(d amqp.Delivery) {
		fmt.Println(string(d.Body))
		err := d.Ack(false)
		if err != nil {
			panic(err)
		}
	}

	// unpackMe := func(taskStatus client.TaskStatusStructure) {
	// 	fmt.Println("Deadline:       " + taskStatus.Deadline)
	// 	fmt.Println("Scheduler ID:   " + taskStatus.SchedulerId)
	// 	fmt.Println("Task Group ID:  " + taskStatus.TaskGroupId)
	// 	fmt.Println("Task ID:        " + taskStatus.TaskId)
	// 	fmt.Println("Worker Type:    " + taskStatus.WorkerType)
	// 	fmt.Println("")
	// 	err = d.Ack(false)
	// 	if err != nil {
	// 		panic(err)
	// 	}
	// 	fmt.Println(string(d.Body))
	// 	fmt.Println("=====================")
	// }

	q1 := p1.Consume(
		"",      // queue name ("" implies uuid should be generated)
		printMe, // callback function to call with each AMQP delivery...
		1,       // prefetch
		1,       // max length (not yet used)
		false,   // autoAck - we want to acknowledge ourselves
		// List of bindings (variadic - list as many as you want...)
		// Example of simple bindings which just take strings...
		bindings...)
	// pulse.Bind("#", "exchange/build/"),
	// pulse.Bind("#", "exchange/bugzilla/simple"),
	// A custom Binding (using autogenerated types)
	// exchange.TaskDefined{ProvisionerId: "null-provisioner", WorkerType: "buildbot-try"})
	//exchange.TaskDefined{})

	// not yet implemented
	q1.Pause()
	// not yet implemented
	q1.Resume()
	// not yet implemented
	q1.Delete()
	// not yet implemented
	q1.Close()

	// wait for a never-arriving message, to avoid exiting program
	forever := make(chan bool)
	<-forever
}
